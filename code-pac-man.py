import pygame
import sys
import json

# Initialisation de Pygame
pygame.init()

# Définir les couleurs
noir = (0, 0, 0)
jaune = (255, 255, 0)
bleu = (0, 0, 255)

# Définir la taille de la fenêtre
largeur_map, hauteur_map = 450, 496
fenetre = pygame.display.set_mode((largeur_map, hauteur_map))
pygame.display.set_caption("Pac-Man Game")
bg = pygame.image.load("Sprite/Colision-Map.png").convert()

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y, sprite_sheet):
        super().__init__()
        self.sprite_sheet = sprite_sheet
        self.frame_width = 24
        self.frame_height = 24
        self.total_frames = 2
        self.current_frame = 0
        self.animation_speed = 0.08
        self.last_update = pygame.time.get_ticks()
        self.direction = ''

        # Appliquer la couleur noire comme couleur transparente
        self.sprite_sheet.set_colorkey(noir)

        self.image = self.animer_pacman()
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y


    def animer_pacman(self):
        now = pygame.time.get_ticks()
        if now - self.last_update > self.animation_speed * 1000:
            self.last_update = now
            self.current_frame = (self.current_frame + 1) % self.total_frames

        frame = pygame.Surface((self.frame_width, self.frame_height), pygame.SRCALPHA)
        frame.blit(self.sprite_sheet, (0, 0), (self.current_frame * self.frame_width, 0, self.frame_width, self.frame_height))

        # Effectue la rotation en fonction de la direction
        if self.direction == 'left':
            frame = pygame.transform.rotate(frame, 180)
        elif self.direction == 'up':
            frame = pygame.transform.rotate(frame, 90)
        elif self.direction == 'down':
            frame = pygame.transform.rotate(frame, -90)

        return frame

    def update(self):
        self.image = self.animer_pacman()
        
    def teleportation(self):
        if(self.rect.x >= 450):
            self.rect.x = -10
        elif(self.rect.x <= -25):
            self.rect.x = 435     

class Fantome(pygame.sprite.Sprite):
    def __init__(self, x, y, image):
        super().__init__()
        self.image = pygame.image.load(image)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.direction = 'left'
        self.changing_direction = False  # Nouvelle variable d'état
        
    def poursuite(self, player):
        target_x = player.rect.x
        target_y = player.rect.y

        possible_directions = []

        # Vérifier les directions possibles en fonction de la cible
        if target_x < self.rect.x and carte[self.rect.y][self.rect.x - 1] != 1:
            possible_directions.append('left')
        elif target_x > self.rect.x and not carte[self.rect.y][self.rect.x + 1] != 1:
            possible_directions.append('right')

        if target_y < self.rect.y and carte[self.rect.y - 1][self.rect.x] != 1:
            possible_directions.append('up')
        elif target_y > self.rect.y and carte[self.rect.y + 1][self.rect.x] != 1:
            possible_directions.append('down')

        # Si le fantôme est actuellement bloqué dans sa direction, il choisit une nouvelle direction
        if self.direction not in possible_directions or self.changing_direction:
            # Choisir une nouvelle direction en fonction de la position du joueur
            if player.rect.y < self.rect.y and carte[self.rect.y - 1][self.rect.x] != 1:
                self.direction = 'up'
            elif player.rect.y > self.rect.y and carte[self.rect.y + 1][self.rect.x] != 1:
                self.direction = 'down'
            elif player.rect.x < self.rect.x and carte[self.rect.y][self.rect.x - 1] != 1:
                self.direction = 'left'
            elif player.rect.x > self.rect.x and carte[self.rect.y][self.rect.x + 1] != 1:
                self.direction = 'right'

            self.changing_direction = False

    def update(self, player):
        # Choix de la fonction de poursuite en fonction du fantôme
        self.poursuite(player)

        # Gestion des collisions avec les murs en fonction de la direction
        if not self.changing_direction:
            if self.direction == 'left' and carte[self.rect.y][self.rect.x - 1] != 1:
                self.try_change_direction('left', ['up', 'down'])
            elif self.direction == 'right' and carte[self.rect.y][self.rect.x + 1] != 1:
                self.try_change_direction('right', ['up', 'down'])
            elif self.direction == 'up' and carte[self.rect.y - 1][self.rect.x] != 1:
                self.try_change_direction('up', ['left', 'right'])
            elif self.direction == 'down' and carte[self.rect.y + 1][self.rect.x] != 1:
                self.try_change_direction('down', ['left', 'right'])

            # Si le fantôme est toujours bloqué, choisir une nouvelle direction
            if carte[self.rect.y][self.rect.x - 1] == 1 and carte[self.rect.y][self.rect.x + 1] == 1 and \
                    carte[self.rect.y - 1][self.rect.x] == 1 and carte[self.rect.y + 1][self.rect.x] == 1:
                self.changing_direction = True

        # Gestion des collisions avec les murs en fonction de la direction
        if not self.changing_direction:
            if self.direction == 'left' and carte[self.rect.y][self.rect.x - 1] != 1:
                self.rect.x -= 1
            elif self.direction == 'right' and carte[self.rect.y][self.rect.x + 1] != 1:
                self.rect.x += 1
            elif self.direction == 'up' and carte[self.rect.y - 1][self.rect.x] != 1:
                self.rect.y -= 1
            elif self.direction == 'down' and carte[self.rect.y + 1][self.rect.x] != 1:
                self.rect.y += 1

        # Réinitialiser l'état de changement de direction après avoir traversé un mur
        self.changing_direction = False

    def try_change_direction(self, new_direction, forbidden_directions):
        # Choisir une nouvelle direction si le fantôme est actuellement bloqué dans une direction interdite
        if self.direction in forbidden_directions:
            self.direction = new_direction


class Game:
    def __init__(self):
        pacman_spritesheet = pygame.image.load("Sprite/Sprite.png").convert()
        self.player = Player(7,7, pacman_spritesheet)
        
        # Création des fantômes
        self.fantomes = pygame.sprite.Group()
        self.blinky = Fantome(50, 45, 'Sprite/Fantome.png')
        self.pinky = Fantome(10, 10, 'Sprite/Fantome.png')
        self.inky = Fantome(20, 20, 'Sprite/Fantome.png')
        self.clyde = Fantome(25, 25, 'Sprite/Fantome.png')

        self.fantomes.add(self.blinky,self.pinky, self.inky, self.clyde)
        
        # Définition des fantômes principaux
        self.blinky = self.fantomes.sprites()[0]
        self.pinky = self.fantomes.sprites()[1]
        self.inky = self.fantomes.sprites()[2]
        self.clyde = self.fantomes.sprites()[3]



game = Game()


with open("map.json", "r") as fichier:
    carte = json.load(fichier)
taille_case = 1.6
# Boucle principale du jeu
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    # Gestion des déplacements
    touches = pygame.key.get_pressed()

    if touches[pygame.K_LEFT] and carte[game.player.rect.y][game.player.rect.x - 1] != 1:
        game.player.direction = 'left'
    elif touches[pygame.K_RIGHT] and carte[game.player.rect.y][game.player.rect.x + 1] != 1:
        game.player.direction = 'right'
    elif touches[pygame.K_UP] and carte[game.player.rect.y - 1][game.player.rect.x] != 1:
        game.player.direction = 'up'
    elif touches[pygame.K_DOWN] and carte[game.player.rect.y + 1][game.player.rect.x] != 1:
        game.player.direction = 'down'

    # Met à jour la position de Pac-Man en fonction de la direction
    if game.player.direction == 'left' and carte[game.player.rect.y][game.player.rect.x - 1] != 1:
        game.player.rect.x -= 2
    elif game.player.direction == 'right' and carte[game.player.rect.y][game.player.rect.x + 1] != 1:
        game.player.rect.x += 2
    elif game.player.direction == 'up' and carte[game.player.rect.y - 1][game.player.rect.x] != 1:
        game.player.rect.y -= 2
    elif game.player.direction == 'down' and carte[game.player.rect.y + 1][game.player.rect.x] != 1:
        game.player.rect.y += 2

   
     # Appelle la fonction pour animer Pac-Man avec la direction
    game.player.update()
     
    # Appelle la fonction pour téléporter Pac-Man en fonction de sa localisation
    game.player.teleportation()
    # Dessiner la carte
    for i in range(len(carte)):
        for j in range(len(carte[i])):
            if carte[i][j] == 1:
                pygame.draw.rect(fenetre, bleu, (j * taille_case, i * taille_case, taille_case, taille_case))
    
    # Rafraîchir l'écran
     
    fenetre.blit(bg, (0, 0))  
     # Fonction de poursuite des fantômes
    for fantome in game.fantomes:
        fantome.update(game.player)
        
    # Dessiner Pac-Man
    fenetre.blit(game.player.image, (game.player.rect.x * taille_case, game.player.rect.y * taille_case))
    fenetre.blit(game.blinky.image,(game.blinky.rect.x * taille_case, game.blinky.rect.y * taille_case))
    pygame.display.flip()
    print(game.player.rect.x,game.player.rect.y)
    # Limiter la vitesse du jeu
    pygame.time.Clock().tick(1200)
